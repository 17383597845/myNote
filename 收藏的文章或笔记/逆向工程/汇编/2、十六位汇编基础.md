## 一、汇编基础和debug使用
### 1、了解硬件运行机制
为什么计算机的操作数据的单位是二进制？
	答：电子器件二极管，正向加电则通，反向加电则不通，用通与不通表示二进制的零和一。使用一系列的门电路就可以实现各种位运算。
机器码示例（通过控制电路实现以下运算）：
	15 + 23
		00 00001111 00010111  ——控制位   操作数1  操作数2
	 15 & 23
		 10 00001111 00010111 ——控制位   操作数1  操作数2
	 15 ^ 23
		 11 0000 1111 00010111 ——控制位   操作数1  操作数2
	指令(instructions)示例：
		 00  --- add
		 01 ---- sub
		 10  --- and
		 11 --- xor
		 add 0f ，17  助记符 （Mnemonic）+ 操作数（Operand）
		 and 0f , 17    助记符 + 操作数
		 xor 0f , 17   助记符 + 操作数
	硬件运行：
	助记符 --------》汇编器 -------------》机器码 -----------》执行
### 2、了解微机系统硬件组成
	![[Pasted image 20240723144838.png]]

	![[Pasted image 20240723145925.png]]
	![[Pasted image 20240723145957.png]]
	寻址   00
	读        01
	写        10
	地址0x14，写入0x88
	00 00010100  寻址14 
	10 10001000   写入88
### 3、了解计算机系统组成
	 ![[Pasted image 20240723150603.png]]
		从编写完以下代码到屏幕显示字符中间发生了什么？
	```c
			   #include <stdio.h>
			   int main(){
				   printf("hello world");
			   }
	```
	![[Pasted image 20240723150724.png]]
	![[Pasted image 20240723150747.png]]
	 ![[Pasted image 20240723150830.png]]
### 4、 8086cpu组织架构
	![[Pasted image 20240723150952.png]]
		什么累加器，基址寄存器，这些名字都是没有意义的。通用寄存器都没有什么区别，你的指令想怎么操作就怎么操作。
	![[Pasted image 20240723152143.png]]
	8086cpu将指令的执行分成多个模块，有什么好处？
		![[Pasted image 20240723152850.png]]
### 5、debug使用：
 环境配置：
		 1.xp系统自带，window10没有
		 2.dosbox----在win10安装模拟16位环境
```
		 双击这个文件 DOSBox 0.74-3 Options.bat
		 mount 盘符  真机上的路径
		 mount c  e:\cr41\16asm
		 设置环境变量
		 set path=c:\
		 下载debug.exe到c盘映射文件夹，环境配置完成
```
debug常用命令：
```
	 ?          列出帮助文档
	 u [range]        反汇编
	 a [addr]         汇编，不加地址从上次中断处开始
	 r [reg]                查看寄存器
	 r ax             修改ax寄存器的值
	 d [range]         查看内存
	 e addr            修改内存
     g                  f5 调试
     t                  f11 步入
     p                  f10 步过
     写入文件(n,cx,w)   n文件名，cx文件大小，w文件内容
     n text.txt
     cx 100
     w
	 
```

### 6、标志寄存器
  ![[Pasted image 20240725224540.png]]
#### (1)进位标志cf：
  当运算结果的最高有效位有进位（加法）或借位（减法）时设置。
   进位标志置1，即CF=1(CY)；否则CF=0(NC)；
   举例：
	   3AH + 7CH = B6H,没有进位：CF = 0
	   AAH + 7CH =(1)26H,有进位：CF = 1 
```cmd
   a
   mov al,3a
   add al,7c
   
   u
   r
   t
   t
   mov al,aa
   add al,7c
   ......
```
#### (2) 零标志ZF
当运算结果为0 则ZF=1(NZ);反之ZF=0(ZR)
举例：
	3AH + 7CH = B6H,结果不是零：ZF = 0(NZ)
	 84H + 7CH = (1)00H,结果是零：ZF = 1(ZR)
#### (3)溢出标志OF（针对有符号数）
加法：若同符号数相加，结果的符号与之相反则OF=1,否则OF置0
减法：被减数与减数异号，而结果的符号与减数相同则OF=1,否则置0.
举例：发生了溢出，说明运算结果不可信。
	3AH + 7CH = B6H,没有溢出：OF = 0（PL）  negative
	 AAH + 7CH = (1)26H,产生溢出：OF  = 1 (NG)  plus
#### (4)进位和溢出
进位针对的是无符号数运算，溢出针对的是有符号数运算。当看成无符号数，则关注CF标志，看成有符号数，则关注OF标志。
#### (5)符号标志SF
当运算结果最高位为1，SF=1,否则为0。有符号数据用最高有效位表示数据符号，最高有效位是符号标志的状态。
举例：
	3AH + 7CH = B6H,最高位D7 = 1：SF  = 1（OU）
	84H + 7CH = (1)00H,最高位D7 = 0：SF = 0（NU）
#### (6)奇偶标志位PF
当运算结果（指低8位）中1的个数为偶数时，PF置1(PE)，否则置0(PO)
作用：做奇偶校验，验证检测数据在传输过程中的错误。
举例：
	3AH + 7CH = B6H =10110110B
	 结果中5个1，是奇数置位0。
#### (7)辅助进位标志位AF
	![[Pasted image 20240725231545.png]]


