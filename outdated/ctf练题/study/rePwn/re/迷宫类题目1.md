# Maze

### Maze简介：

迷宫题在CTF游戏题中可以说是一种比较常见的题型。这类题型模拟了一个迷宫，要求选手找到从起点到终点的路径。

通常，选手需要通过输入四个键—W、A、S、D，来控制迷宫中的角色上下左右移动，当然这四个键有时也可能会有所变换。在解决这类题目时，最终的flag通常是由起点到终点的路径构成。

对于简单的迷宫题一般只要找到地图，就可以人工编写出对应迷宫题的flag，随着难度的增加，地图可能变得很大，或者需要解决多张地图组合而成的多维地图结构。  
![图片描述](https://bbs.kanxue.com/upload/attach/202311/920613_5UQC9XDG7E38C7X.webp)

### 分析一个简单的Maze程序分析：

这里我们可以尝试编写一个简单的maze程序，如下定义了一个码表，地图大小为10*10的，为了`#`字符为这个地图的墙或者说陷阱，字符`S`为地图的起始点，字符`E`为地图的终点，`*`为地图中可以走的路径。

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>11<br><br>12<br><br>13<br><br>14<br><br>15<br><br>16<br><br>17<br><br>18<br><br>19<br><br>20<br><br>21<br><br>22<br><br>23<br><br>24<br><br>25<br><br>26<br><br>27<br><br>28<br><br>29<br><br>30<br><br>31<br><br>32<br><br>33<br><br>34<br><br>35<br><br>36<br><br>37<br><br>38<br><br>39<br><br>40<br><br>41|`#include <stdio.h>`<br><br>`#include <stdlib.h>`<br><br>`char maze [``100``]` `=` `{`<br><br>     `'#'``,` `'S'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,`<br><br>     `'#'``,` `'*'``,` `'*'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,`<br><br>     `'#'``,` `'#'``,` `'*'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,`<br><br>     `'#'``,` `'#'``,` `'*'``,` `'*'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,`<br><br>     `'#'``,` `'#'``,` `'#'``,` `'*'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,`<br><br>     `'#'``,` `'*'``,` `'*'``,` `'*'``,` `'#'``,` `'#'``,` `'#'``,` `'E'``,` `'#'``,` `'#'``,`<br><br>     `'#'``,` `'*'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'*'``,` `'#'``,` `'#'``,`<br><br>     `'#'``,` `'*'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'*'``,` `'#'``,` `'#'``,`<br><br>     `'#'``,` `'*'``,` `'*'``,` `'*'``,` `'*'``,` `'*'``,` `'*'``,` `'*'``,` `'#'``,` `'#'``,`<br><br>     `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'`<br><br>`};`<br><br>`int` `main() {`<br><br>    `int` `t` `=` `1``, i;`<br><br>    `char move[``24``];`<br><br>    `scanf_s(``" %s"``, move, sizeof(move));`<br><br>    `for` `(i` `=` `0``; move[i];i``+``+``) {`<br><br>        `switch (move[i]) {`<br><br>        `case` `'w'``: t` `-``=` `10``;` `break``;`<br><br>        `case` `'a'``: t``-``-``;` `break``;`<br><br>        `case` `'s'``: t` `+``=` `10``;` `break``;`<br><br>        `case` `'d'``: t``+``+``;` `break``;`<br><br>        `default:` `continue``;`  `/``/` `Invalid move, do nothing`<br><br>        `}`<br><br>        `if` `(maze[t]` `=``=` `'#'``) {`<br><br>            `printf(``"I'm sorry,The player is dead!"``);`<br><br>            `exit(``1``);`<br><br>        `}`<br><br>        `if` `(maze[t]` `=``=` `'E'``) {`<br><br>            `printf(``"Congratulations, you've found the exit!\n"``);`<br><br>                        `printf(``"Flag is your Input\n"``);`<br><br>        `}`<br><br>    `}`<br><br>    `return` `0``;`<br><br>`}`|

程序要求将路径一次性输入，这里的for就是对输入的路径逐个进行判断，这里需要补充一个点，由于上面代码中的地图使用的是一维数组，所以下标针对上下操作时是直接加减列数，这个地方应该好理解。关于地图比较直观的显示当然还是用二维数组好一点，不过这个题作为入门题，使用一维数组有一个好处就是可以通过下标推测出地图的列数，关于这个点逆向分析完这个代码就可以大概理解。

二维数组的表示以及switch判断可以这么写：

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>11<br><br>12<br><br>13<br><br>14<br><br>15<br><br>16<br><br>17<br><br>18<br><br>19<br><br>20<br><br>21<br><br>22<br><br>23|`#define SIZE 10`<br><br>`char` `maze[SIZE][SIZE] = {`<br><br>    `{``'S'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``},`<br><br>    `{``'#'``,` `'*'``,` `'*'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``},`<br><br>    `{``'#'``,` `'#'``,` `'*'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``},`<br><br>    `{``'#'``,` `'#'``,` `'*'``,` `'*'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``},`<br><br>    `{``'#'``,` `'#'``,` `'#'``,` `'*'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``},`<br><br>    `{``'#'``,` `'*'``,` `'*'``,` `'*'``,` `'#'``,` `'#'``,` `'#'``,` `'E'``,` `'#'``,` `'#'``},`<br><br>    `{``'#'``,` `'*'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'*'``,` `'#'``,` `'#'``},`<br><br>    `{``'#'``,` `'*'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'*'``,` `'#'``,` `'#'``},`<br><br>    `{``'#'``,` `'*'``,` `'*'``,` `'*'``,` `'*'``,` `'*'``,` `'*'``,` `'*'``,` `'#'``,` `'#'``},`<br><br>    `{``'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``,` `'#'``}`<br><br>`};`<br><br>`scanf``(``" %c"``, &move);`<br><br>    `switch``(move) {`<br><br>        `case` `'w'``:` `if` `(x > 0 && maze[x-1][y] !=` `'#'``) x--;` `break``;`<br><br>        `case` `'a'``:` `if` `(y > 0 && maze[x][y-1] !=` `'#'``) y--;` `break``;`<br><br>        `case` `'s'``:` `if` `(x < SIZE-1 && maze[x+1][y] !=` `'#'``) x++;` `break``;`<br><br>        `case` `'d'``:` `if` `(y < SIZE-1 && maze[x][y+1] !=` `'#'``) y++;` `break``;`<br><br>        `default``:` `printf``(``"Invalid move!\n"``);`<br><br>    `}`|

大概知道了maze程序大概是个啥样子之后将它编译成可执行程序，然后用ida打开看一下：

![图片描述](https://bbs.kanxue.com/upload/attach/202311/920613_UVUEWCH42UTKCFV.webp)

这就是程序反汇编之后的内容，可以看到maze类型的题目的特点，这类程序会有一个switch对四个方向进行相应的下标操作。接着关注到33行的v5加等10这条语句，通过这条语句就可以判断出地图每列一定是10个元素，接着就是找地图了，aSE很明显就是这个程序的地图：

![图片描述](https://bbs.kanxue.com/upload/attach/202311/920613_3SBWSUG4PR8ZPMC.webp)

找到地图之后将其提取出来进行手工整理，接着就能获得起点到终点的路径：  
![图片描述](https://bbs.kanxue.com/upload/attach/202311/920613_4HFD4WW77HW6CVP.webp)

获得flag：`sdssdssaasssddddddwww`

通过对这个例子的分析此时对maze题已经有了一定的了解，下面从易到难分析几个实例。

## 实例闯关：

下面的示例会遇到逆向中其他的逆向技术比如去壳和去花等，这些知识点有些在前面的博客中写过，可以翻翻前面的几篇文章，这篇文章主要是分析maze题的解题思路，如果涉及了还没写过的知识点这里不会细讲，之后会单开文章。

### 实例一：Buuoj Maze：

拿到程序后先了解加壳情况以及程序的位数：

![图片描述](https://bbs.kanxue.com/upload/attach/202311/920613_WT3PN3RKYAB5YRJ.webp)

脱壳：

![图片描述](https://bbs.kanxue.com/upload/attach/202311/920613_D9MZQRBPCUAGNX9.webp)

脱壳之后放到ida中发现加了花指令：

![图片描述](https://bbs.kanxue.com/upload/attach/202311/920613_DHJAJDCMSD76K7K.webp)

将其nop后按p识别函数然后f5反汇编就可以成功看到main函数了。

将反汇编后代码的符号稍作优化：

![图片描述](https://bbs.kanxue.com/upload/attach/202311/920613_5ZXQP35Y82ZFQHU.webp)

根据前面的经验我们需要找到地图以及地图的行列数，先尝试找找地图，发现主函数的逻辑没有地图相关的变量，怎么解决呢？

这里尝试shift+f12查找字符串：  
![图片描述](https://bbs.kanxue.com/upload/attach/202311/920613_PCGSYMNXCNBHWBJ.webp)

可以看到上图的字符串就是地图。找到地图后继续找地图的行列数，之前我们判断行列数是通过switch里面对下标的加减来判断的，但是这个实例有点不同，他用了两个下标进行操作，也就是说一个下标对横坐标进行判定，一个下标对纵坐标进行判定，然后在下面的if直接对横纵坐标分别进行判定，到了这里我们就无法直观的推测出这个地图的行列数。

既然推测不出来那就干脆直接爆破出行列。首先提取出来的地图有70个字符，那么70除以列数肯定是可以整除的，首先写一个简单的脚本输出70的所有正因子。

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4|`list` `=` `[]`                `#关于for的取值范围:`<br><br>`for` `i` `in` `range``(``5``,``36``):`    `#1.伪代码的最后的if判断其中有个数要为5,所以行列必定大于5`<br><br>    `if` `70``%``i` `=``=` `0``:`        `#2.一个数的因子不可能大于它的一半`<br><br>        `list``.append(i)`|

通过得出来的值直接进行爆破：

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7|`for` `j` `in` `list``:`<br><br>    `for` `i` `in` `range``(``len``(maze)):`<br><br>        `print``(maze[i],end``=``'')`<br><br>        `if` `(i``+``1``)``%``j``=``=``0``:`<br><br>            `print``()`<br><br>    `print``(``'---------------------'``)`|

最后从脚本输出的结果中，下面这个是最正常的

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7|`*``*``*``*``*``*``*``+``*``*`<br><br>`*``*``*``*``*``*``*` `*``*`<br><br>`*``*``*``*`    `*``*`<br><br>`*``*`   `*``*``*``*``*`<br><br>`*``*` `*``*``F``*``*``*``*`<br><br>`*``*`    `*``*``*``*`<br><br>`*``*``*``*``*``*``*``*``*``*`|

这个地图依旧很小，直接手写出flag即可。

flag{ssaaasaassdddw}

### 实例二：Buuoj ****Oruga****

main函数分析

这个程序没加壳直接放入ida

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>11<br><br>12<br><br>13<br><br>14<br><br>15<br><br>16<br><br>17<br><br>18<br><br>19<br><br>20<br><br>21<br><br>22<br><br>23<br><br>24<br><br>25<br><br>26<br><br>27<br><br>28<br><br>29<br><br>30<br><br>31<br><br>32|`__int64` `__fastcall main(``int` `a1,` `char` `**a2,` `char` `**a3)`<br><br>`{`<br><br>  `__int64` `result;` `// rax`<br><br>  `int` `i;` `// [rsp+0h] [rbp-40h]`<br><br>  `char` `s1[6];` `// [rsp+4h] [rbp-3Ch] BYREF`<br><br>  `char` `s2[6];` `// [rsp+Ah] [rbp-36h] BYREF`<br><br>  `char` `s[40];` `// [rsp+10h] [rbp-30h] BYREF`<br><br>  `unsigned` `__int64` `v8;` `// [rsp+38h] [rbp-8h]`<br><br>  `v8 = __readfsqword(0x28u);`<br><br>  `memset``(s, 0, 0x19uLL);`<br><br>  `printf``(``"Tell me the flag:"``);`<br><br>  `scanf``(``"%s"``, s);`<br><br>  `strcpy``(s2,` `"actf{"``);`<br><br>  `for` `( i = 0; i <= 4; ++i )`<br><br>    `s1[i] = s[i];`<br><br>  `s1[5] = 0;`<br><br>  `if` `( !``strcmp``(s1, s2) )`<br><br>  `{`<br><br>    `if` `( (unsigned` `__int8``)sub_78A(s) )`<br><br>      `printf``(``"That's True Flag!"``);`<br><br>    `else`<br><br>      `printf``(``"don't stop trying..."``);`<br><br>    `result = 0LL;`<br><br>  `}`<br><br>  `else`<br><br>  `{`<br><br>    `printf``(``"Format false!"``);`<br><br>    `result = 0LL;`<br><br>  `}`<br><br>  `return` `result;`<br><br>`}`|

第一个for循环是将输入的字串的前5个字符拿出来和“actf{”进行比较，配对成功则调用`sub_78A()` 函数

sub_78A分析：

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>11<br><br>12<br><br>13<br><br>14<br><br>15<br><br>16<br><br>17<br><br>18<br><br>19<br><br>20<br><br>21<br><br>22<br><br>23<br><br>24<br><br>25<br><br>26<br><br>27<br><br>28<br><br>29<br><br>30<br><br>31<br><br>32<br><br>33<br><br>34<br><br>35<br><br>36<br><br>37<br><br>38<br><br>39<br><br>40<br><br>41<br><br>42<br><br>43<br><br>44<br><br>45<br><br>46<br><br>47<br><br>48<br><br>49<br><br>50<br><br>51<br><br>52|`_BOOL8 __fastcall sub_78A(``__int64` `a1)`<br><br>`{`<br><br>  `int` `v2;` `// [rsp+Ch] [rbp-Ch]`<br><br>  `int` `v3;` `// [rsp+10h] [rbp-8h]`<br><br>  `int` `v4;` `// [rsp+14h] [rbp-4h]`<br><br>  `v2 = 0;`<br><br>  `v3 = 5;`<br><br>  `v4 = 0;`<br><br>  `while` `( byte_201020[v2] != 0x21 )`<br><br>  `{`<br><br>    `v2 -= v4;`<br><br>    `if` `( *(_BYTE *)(v3 + a1) !=` `'W'` `\| v4 == -16 )`<br><br>    `{`<br><br>      `if` `( *(_BYTE *)(v3 + a1) !=` `'E'` `\| v4 == 1 )`<br><br>      `{`<br><br>        `if` `( *(_BYTE *)(v3 + a1) !=` `'M'` `\| v4 == 16 )`<br><br>        `{`<br><br>          `if` `( *(_BYTE *)(v3 + a1) !=` `'J'` `\| v4 == -1 )`<br><br>            `return` `0LL;`<br><br>          `v4 = -1;`                              `// J表示左移`<br><br>        `}`<br><br>        `else`<br><br>        `{`<br><br>          `v4 = 16;`                              `// M表示下移`<br><br>        `}`<br><br>      `}`<br><br>      `else`<br><br>      `{`<br><br>        `v4 = 1;`                                 `// E表示右移`<br><br>      `}`<br><br>    `}`<br><br>    `else`<br><br>    `{`<br><br>      `v4 = -16;`                                 `// W表示上移`<br><br>    `}`<br><br>    `++v3;`<br><br>    `while` `( !byte_201020[v2] )`                  `// 当前值为0则继续循环`<br><br>    `{`<br><br>      `if` `( v4 == -1 && (v2 & 0xF) == 0 )`        `// 当前在最左边一列的时候，不能过左移`<br><br>        `return` `0LL;`<br><br>      `if` `( v4 == 1 && v2 % 16 == 15 )`           `// 当前在最右边一列的时候，不能够右移`<br><br>        `return` `0LL;`<br><br>      `if` `( v4 == 16 && (unsigned` `int``)(v2 - 240) <= 0xF )``// 在最后一行时，不能下移`<br><br>        `return` `0LL;`<br><br>      `if` `( v4 == -16 && (unsigned` `int``)(v2 + 15) <= 0x1E )``// 在第一行，不能上移`<br><br>        `return` `0LL;`<br><br>      `v2 += v4;`                  `// 当值为0就一直移动，但要注意退出循环时一定已经处于不满`<br><br>    `}`                            `// 的状态所以对于走迷宫来说时多移动了一次，在12行做了一`    <br><br>  `}`                              `// 个往后退一步的处理`<br><br>  `return` `*(_BYTE *)(v3 + a1) == 125;`<br><br>`}`|

这里看到一个迷宫题的特征就是13到19行的四个字母，发现这个点后就去找地图，发现byte_201020里面的值：

![图片描述](https://bbs.kanxue.com/upload/attach/202311/920613_HZUQ6EQHCNS9667.webp)

通过v4要么加16，要么加1，和这个数组的大小为256可知，这是张16*16的地图，直接去Hex窗口里看：

![图片描述](https://bbs.kanxue.com/upload/attach/202311/920613_ZBQP87UKRN6RN9C.webp)

大概是个这么个走法：  
![图片描述](https://bbs.kanxue.com/upload/attach/202311/920613_3Y29YM5SUB2DB6Z.webp)

转换成字母就是：MEWEMEWJMEWJM

这个题目和前面程序的主要区别就是，前面分析的程序每次移动一个位置，而这个题目每次移动都会一直移动到撞墙才停止，实现这部分的代码为主函数的while循环，我在主函数上加了注释，可以理一理这个程序的思路。

### 实例三：**Volga Quals CTF 2014: Reverse 100**

- 题目附件
    
    [ciscn_2019_n_1](https://bbs.kanxue.com/Maze%207632b5439dec4ff4930308a213f1ab61/ciscn_2019_n_1.txt)
    
    把后缀去掉即可，下面的几个附件同理
    

直接使用ida打开程序，主函数中很多字符串的内存赋值操作：

![图片描述](https://bbs.kanxue.com/upload/attach/202311/920613_KX8UBGH4F3JQYEG.webp)

紧接着是一个while判断：

![图片描述](https://bbs.kanxue.com/upload/attach/202311/920613_3AVK3HRC6XXJ4TS.webp)

看到了四个if，分别判断了四个字符L、R、U、D，然后L、R影响的变量为pos_x；U、D影响的变量为pos_y。这个循环的作用就不用多说了，UDLR分别代表上下左右。pos_x表示行下标，pos_y表示列下标。这个题目很清晰，上面那一大堆字符串的内存赋值明显就是构成地图了。回到构成地图的代码处发现一个比较恶心的地方：

![图片描述](https://bbs.kanxue.com/upload/attach/202311/920613_G99X5QJJSAGXYME.webp)

地图是一行一行复制到内存的，关键是打乱了顺序，每一行都有对应的行号，将地图提取出来后，需要按照行号恢复顺序，这里可以一次性将值提取出来后，写一个脚本恢复顺序虽然也没有方便到哪去。

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>11<br><br>12<br><br>13<br><br>14<br><br>15<br><br>16<br><br>17<br><br>18<br><br>19<br><br>20<br><br>21<br><br>22<br><br>23<br><br>24<br><br>25<br><br>26<br><br>27<br><br>28<br><br>29<br><br>30<br><br>31<br><br>32<br><br>33<br><br>34<br><br>35<br><br>36<br><br>37<br><br>38<br><br>39<br><br>40<br><br>41|`maze = [`<br><br>    `"**########################################################################################"``,`<br><br>    `"#************######*##############**************##*####*#######*##*##*###*#####*####*#####"``,`<br><br>    `"###*#########*****************************************************************############"``,`<br><br>    `"###*#########*###############################################*######*****************#####"``,`<br><br>    `"###**********#############################################################################"``,`<br><br>    `"#*######################*******************************************#####*************#####"``,`<br><br>    `"############*#####*******************************************************************#####"``,`<br><br>    `"###*#################################################*#########*##*######*#####*####*#####"``,`<br><br>    `"###*####*****#####**********************#############*#########*##********#####*####*#####"``,`<br><br>    `"#************************####*####################################*#####*###########*#####"``,`<br><br>    `"###*####*###*#####*############################################*****************####*#####"``,`<br><br>    `"###*####*###*#####*####################***************#########*###############*####*#####"``,`<br><br>    `"#########*#########*#########*#######***************************##*#####*###########*#####"``,`<br><br>    `"#############################################################*######*#####################"``,`<br><br>    `"#******##*#########*#########*#######*#########################*##*#####*###########*#####"``,`<br><br>    `"#*####*##*#########*#########*#######*#########################*##*#####********####*#####"``,`<br><br>    `"###******###*#####*#################################################################*#####"``,`<br><br>    `"###*#########*###############################################*############################"``,`<br><br>    `"#*####*##*#########*######*******####*###**********####****####*##*############*####*#####"``,`<br><br>    `"#*##***#**#########*#################*###*########*####*#######*##*############*####*#####"``,`<br><br>    `"###**************************************************########*######*#####################"``,`<br><br>    `"#*##*###*##########*##############****###*******##*####*#######*##*##*****#####*####*#####"``,`<br><br>    `"#*##*###*##########*##############*############*##*####*#######*##*##*###*#####*####*#####"``,`<br><br>    `"###################*##############################*####***#####*##*##*###*#####*####*#####"``,`<br><br>    `"###################********************************############*##*##*###*#####*####*#####"``,`<br><br>    `"###############################################################*##*##*###*#####*####*#####"``,`<br><br>    `"#########################*****************************************************************"``,`<br><br>    `"###***************************************************#########*##*##*###*#####*####*#####"``,`<br><br>    `"#############################################################*######*#####################"``,`<br><br>    `"#*#######*####**###*#######***#######*########**###*******##*****##########################"``,`<br><br>    `"##*#####*###*###*##*######*#########*#*######*##*#####*#####*##############################"``,`<br><br>    `"###*###*####*###*##*######*##**####*###*####*#########*#####***############################"``,`<br><br>    `"####*#*#####*###*##*##*###*###*###*******####*##*#####*#####*##############################"``,`<br><br>    `"#####*#######**####****####**####*#######*####**######*#####*##############################"`<br><br>`]`<br><br>`list = [0, 10, 22, 24, 21, 1, 20, 15, 16, 2, 18, 17, 3, 26, 4, 5, 19, 23, 6, 7, 25, 8, 9, 11, 12, 13, 28, 14, 27, 29, 30, 31, 32, 33]`<br><br>`with open(``'maze.txt'``,` `'w'``) as f:`<br><br>    `# 遍历行号列表，将对应的字符串写入到文件中`<br><br>    `for` `i in range(len(list)):`<br><br>        `print(maze[list.index(i)], file=f)`|

上面的脚本将恢复顺序的地图输出到一个文件中，然后查看地图会发现这个地图还不小：

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>11<br><br>12<br><br>13<br><br>14<br><br>15<br><br>16<br><br>17<br><br>18<br><br>19<br><br>20<br><br>21<br><br>22<br><br>23<br><br>24<br><br>25<br><br>26<br><br>27<br><br>28<br><br>29<br><br>30<br><br>31<br><br>32<br><br>33<br><br>34|`**########################################################################################`<br><br>`#*######################*******************************************#####*************#####`<br><br>`#************************####*####################################*#####*###########*#####`<br><br>`#########*#########*#########*#######***************************##*#####*###########*#####`<br><br>`#******##*#########*#########*#######*#########################*##*#####*###########*#####`<br><br>`#*####*##*#########*#########*#######*#########################*##*#####********####*#####`<br><br>`#*####*##*#########*######*******####*###**********####****####*##*############*####*#####`<br><br>`#*##***#**#########*#################*###*########*####*#######*##*############*####*#####`<br><br>`#*##*###*##########*##############****###*******##*####*#######*##*##*****#####*####*#####`<br><br>`#*##*###*##########*##############*############*##*####*#######*##*##*###*#####*####*#####`<br><br>`#************######*##############**************##*####*#######*##*##*###*#####*####*#####`<br><br>`###################*##############################*####***#####*##*##*###*#####*####*#####`<br><br>`###################********************************############*##*##*###*#####*####*#####`<br><br>`###############################################################*##*##*###*#####*####*#####`<br><br>`###***************************************************#########*##*##*###*#####*####*#####`<br><br>`###*#################################################*#########*##*######*#####*####*#####`<br><br>`###*####*****#####**********************#############*#########*##********#####*####*#####`<br><br>`###*####*###*#####*####################***************#########*###############*####*#####`<br><br>`###*####*###*#####*############################################*****************####*#####`<br><br>`###******###*#####*#################################################################*#####`<br><br>`############*#####*******************************************************************#####`<br><br>`###**********#############################################################################`<br><br>`###*#########*****************************************************************############`<br><br>`###*#########*###############################################*############################`<br><br>`###*#########*###############################################*######*****************#####`<br><br>`###**************************************************########*######*#####################`<br><br>`#############################################################*######*#####################`<br><br>`#############################################################*######*#####################`<br><br>`#########################*****************************************************************`<br><br>`#*#######*####**###*#######***#######*########**###*******##*****#########################`<br><br>`##*#####*###*###*##*######*#########*#*######*##*#####*#####*#############################`<br><br>`###*###*####*###*##*######*##**####*###*####*#########*#####***###########################`<br><br>`####*#*#####*###*##*##*###*###*###*******####*##*#####*#####*#############################`<br><br>`#####*#######**####****####**####*#######*####**######*#####*#############################`|

碰到这种大地图一个一个手写方向会非常麻烦，这时候就要引入一个知识点：利用BFS算法寻找最短路径，如果对这个算法不是很熟悉的话可以看我的上一篇文章，搞定这个知识点，最好是自己写一个脚本出来以后碰到类似问题就可以改改数据直接用。下面是这个题的BFS脚本：

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>11<br><br>12<br><br>13<br><br>14<br><br>15<br><br>16<br><br>17<br><br>18<br><br>19<br><br>20<br><br>21<br><br>22<br><br>23<br><br>24<br><br>25<br><br>26<br><br>27<br><br>28<br><br>29<br><br>30<br><br>31<br><br>32<br><br>33<br><br>34<br><br>35<br><br>36<br><br>37<br><br>38<br><br>39<br><br>40<br><br>41<br><br>42<br><br>43<br><br>44<br><br>45<br><br>46<br><br>47<br><br>48<br><br>49<br><br>50<br><br>51<br><br>52<br><br>53<br><br>54<br><br>55<br><br>56<br><br>57<br><br>58<br><br>59<br><br>60<br><br>61<br><br>62<br><br>63<br><br>64<br><br>65<br><br>66<br><br>67<br><br>68<br><br>69<br><br>70<br><br>71<br><br>72<br><br>73<br><br>74<br><br>75<br><br>76<br><br>77<br><br>78<br><br>79<br><br>80<br><br>81<br><br>82<br><br>83<br><br>84<br><br>85<br><br>86<br><br>87<br><br>88<br><br>89<br><br>90<br><br>91<br><br>92<br><br>93<br><br>94<br><br>95<br><br>96<br><br>97<br><br>98|`#include <iostream>`<br><br>`#include <queue>`<br><br>`#include <vector>`<br><br>`using` `namespace` `std;`<br><br>`char` `maze[34][91] = {`<br><br>    `"S*########################################################################################"``,`<br><br>    `"#*######################*******************************************#####*************#####"``,`<br><br>    `"#************************####*####################################*#####*###########*#####"``,`<br><br>    `"#########*#########*#########*#######***************************##*#####*###########*#####"``,`<br><br>    `"#******##*#########*#########*#######*#########################*##*#####*###########*#####"``,`<br><br>    `"#*####*##*#########*#########*#######*#########################*##*#####********####*#####"``,`<br><br>    `"#*####*##*#########*######*******####*###**********####****####*##*############*####*#####"``,`<br><br>    `"#*##***#**#########*#################*###*########*####*#######*##*############*####*#####"``,`<br><br>    `"#*##*###*##########*##############****###*******##*####*#######*##*##*****#####*####*#####"``,`<br><br>    `"#*##*###*##########*##############*############*##*####*#######*##*##*###*#####*####*#####"``,`<br><br>    `"#************######*##############**************##*####*#######*##*##*###*#####*####*#####"``,`<br><br>    `"###################*##############################*####***#####*##*##*###*#####*####*#####"``,`<br><br>    `"###################********************************############*##*##*###*#####*####*#####"``,`<br><br>    `"###############################################################*##*##*###*#####*####*#####"``,`<br><br>    `"###***************************************************#########*##*##*###*#####*####*#####"``,`<br><br>    `"###*#################################################*#########*##*######*#####*####*#####"``,`<br><br>    `"###*####*****#####**********************#############*#########*##********#####*####*#####"``,`<br><br>    `"###*####*###*#####*####################***************#########*###############*####*#####"``,`<br><br>    `"###*####*###*#####*############################################*****************####*#####"``,`<br><br>    `"###******###*#####*#################################################################*#####"``,`<br><br>    `"############*#####*******************************************************************#####"``,`<br><br>    `"###**********#############################################################################"``,`<br><br>    `"###*#########*****************************************************************############"``,`<br><br>    `"###*#########*###############################################*############################"``,`<br><br>    `"###*#########*###############################################*######*****************#####"``,`<br><br>    `"###**************************************************########*######*#####################"``,`<br><br>    `"#############################################################*######*#####################"``,`<br><br>    `"#############################################################*######*#####################"``,`<br><br>    `"#########################****************************************************************E"``,`<br><br>    `"#*#######*####**###*#######***#######*########**###*******##*****#########################"``,`<br><br>    `"##*#####*###*###*##*######*#########*#*######*##*#####*#####*#############################"``,`<br><br>    `"###*###*####*###*##*######*##**####*###*####*#########*#####***###########################"``,`<br><br>    `"####*#*#####*###*##*##*###*###*###*******####*##*#####*#####*#############################"``,`<br><br>    `"#####*#######**####****####**####*#######*####**######*#####*#############################"`<br><br>`};`<br><br>`struct` `Point {`<br><br>    `int` `row, col;`<br><br>    `string path;`  `// 路径跟踪变量`<br><br>`};`<br><br>`bool` `isValid(``int` `row,` `int` `col) {`<br><br>    `// 检查点是否在地图内并且是可行走的`<br><br>    `return` `row >= 0 && row < 34 && col >= 0 && col < 91 && maze[row][col] !=` `'#'``;`<br><br>`}`<br><br>`void` `bfs() {`<br><br>    `queue<Point> q;`<br><br>    `q.push({ 0, 0,` `""` `});`  `// 将起点放入队列中`<br><br>    `bool` `visited[34][91] = {` `false` `};`<br><br>    `visited[0][0] =` `true``;`  `// 该变量用于记录图中的每个节点是否已被访问过`<br><br>    `while` `(!q.empty()) {`<br><br>        `Point p = q.front();`<br><br>        `q.pop();`<br><br>        `int` `row = p.row;`<br><br>        `int` `col = p.col;`<br><br>        `string path = p.path;`<br><br>        `// 判断是否到终点了`<br><br>        `if` `(maze[row][col] ==` `'E'``) {`<br><br>            `cout << path << endl;`<br><br>            `return``;`<br><br>        `}`<br><br>        `// 检查每个方向，如果有效就排队`<br><br>        `if` `(isValid(row - 1, col) && !visited[row - 1][col]) {`<br><br>            `q.push({ row - 1, col, path +` `'U'` `});`<br><br>            `visited[row - 1][col] =` `true``;`<br><br>        `}`<br><br>        `if` `(isValid(row + 1, col) && !visited[row + 1][col]) {`<br><br>            `q.push({ row + 1, col, path +` `'D'` `});`<br><br>            `visited[row + 1][col] =` `true``;`<br><br>        `}`<br><br>        `if` `(isValid(row, col - 1) && !visited[row][col - 1]) {`<br><br>            `q.push({ row, col - 1, path +` `'L'` `});`<br><br>            `visited[row][col - 1] =` `true``;`<br><br>        `}`<br><br>        `if` `(isValid(row, col + 1) && !visited[row][col + 1]) {`<br><br>            `q.push({ row, col + 1, path +` `'R'` `});`<br><br>            `visited[row][col + 1] =` `true``;`<br><br>        `}`<br><br>    `}`<br><br>    `cout <<` `"No path found"` `<< endl;`<br><br>`}`<br><br>`int` `main() {`<br><br>    `bfs();`<br><br>    `return` `0;`<br><br>`}`|

![图片描述](https://bbs.kanxue.com/upload/attach/202311/920613_PWYQ2JQMYZ25HWQ.webp)

### 实例四：SCTF2019 babygame

- 题目附件
    
    [babygame](https://bbs.kanxue.com/Maze%207632b5439dec4ff4930308a213f1ab61/babygame.txt)
    

这个题目的考察的知识点不少，地图只是其中一个小的知识点，具体题解可以看博客中的wp复现模块，这里只是将其中的迷宫考点单独拎出来讲。首先看一下去完花指令后的主函数maze部分代码：

![图片描述](https://bbs.kanxue.com/upload/attach/202311/920613_XZ8ADZU5PBSECCJ.webp)

代码中可以直接看到地图字符串，但是观察switch语句，这里判断了六个字符前面的wasd四个字符都好理解也就是上下左右，但是后面的xy就显得十分突兀，一般的地图就只需要走四个方向，这里为啥会有六个字符呢？

这里的地图其实是一张三维地图，不知道各位有没有玩过魔塔这个十分古早的单击游戏，玩家扮演勇士的角色，从塔的第一层开始打怪升级，然后进入第二层继续打怪升级。这就是三维地图，x表示去到上层地图，y表示去到下层地图。也就是说这张地图实际是由五张五乘五的地图构成。

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5|`{``'*'``,``'*'``,``'*'``,``'*'``,``'*'``}`<br><br>`{``'*'``,``'*'``,``'*'``,``'*'``,``'*'``}`<br><br>`{``'*'``,``'*'``,``'*'``,``'*'``,``'.'``}`<br><br>`{``'*'``,``'*'``,``'*'``,``'*'``,``'.'``}`<br><br>`{``'*'``,``'*'``,``'s'``,``'.'``,``'.'``}`|

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5|`{``'*'``,``'*'``,``'*'``,``'*'``,``'*'``}`<br><br>`{``'*'``,``'*'``,``'*'``,``'*'``,``'*'``}`<br><br>`{``'*'``,``'*'``,``'*'``,``'*'``,``'*'``}`<br><br>`{``'*'``,``'*'``,``'*'``,``'*'``,``'*'``}`<br><br>`{``'.'``,``'*'``,``'*'``,``'.'``,``'.'``}`|

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5|`{``'*'``,``'.'``,``'.'``,``'*'``,``'*'``}`<br><br>`{``'*'``,``'*'``,``'*'``,``'*'``,``'.'``}`<br><br>`{``'*'``,``'*'``,``'*'``,``'*'``,``'.'``}`<br><br>`{``'*'``,``'*'``,``'*'``,``'*'``,``'*'``}`<br><br>`{``'*'``,``'*'``,``'*'``,``'*'``,``'*'``}`|

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5|`{``'*'``,``'*'``,``'*'``,``'*'``,``'*'``}`<br><br>`{``'*'``,``'*'``,``'.'``,``'.'``,``'*'``}`<br><br>`{``'*'``,``'.'``,``'.'``,``'.'``,``'*'``}`<br><br>`{``'.'``,``'.'``,``'*'``,``'.'``,``'*'``}`<br><br>`{``'.'``,``'*'``,``'*'``,``'.'``,``'*'``}`|

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5|`{``'*'``,``'.'``,``'.'``,``'*'``,``'*'``}`<br><br>`{``'*'``,``'.'``,``'.'``,``'*'``,``'*'``}`<br><br>`{``'.'``,``'.'``,``'#'``,``'*'``,``'.'``}`<br><br>`{``'.'``,``'*'``,``'*'``,``'*'``,``'.'``}`<br><br>`{``'.'``,``'*'``,``'*'``,``'*'``,``'.'``}`|

根据题目的输出提示需要找到最短的路径，还是使用BFS算法进行查找，之前的代码依然能用，不过要稍作修改，修改时需要注意的地方有：

- 定义的结构体需要多加一个坐标。
- 在循环中还需要添加一个变量来表示不同层

具体的代码如下：

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>11<br><br>12<br><br>13<br><br>14<br><br>15<br><br>16<br><br>17<br><br>18<br><br>19<br><br>20<br><br>21<br><br>22<br><br>23<br><br>24<br><br>25<br><br>26<br><br>27<br><br>28<br><br>29<br><br>30<br><br>31<br><br>32<br><br>33<br><br>34<br><br>35<br><br>36<br><br>37<br><br>38<br><br>39<br><br>40<br><br>41<br><br>42<br><br>43<br><br>44<br><br>45<br><br>46<br><br>47<br><br>48<br><br>49<br><br>50<br><br>51<br><br>52<br><br>53<br><br>54<br><br>55<br><br>56<br><br>57<br><br>58<br><br>59<br><br>60<br><br>61<br><br>62<br><br>63<br><br>64<br><br>65<br><br>66<br><br>67<br><br>68<br><br>69<br><br>70<br><br>71<br><br>72<br><br>73<br><br>74<br><br>75<br><br>76<br><br>77<br><br>78<br><br>79<br><br>80<br><br>81<br><br>82<br><br>83<br><br>84<br><br>85<br><br>86<br><br>87<br><br>88<br><br>89<br><br>90<br><br>91<br><br>92<br><br>93<br><br>94<br><br>95<br><br>96<br><br>97<br><br>98<br><br>99<br><br>100<br><br>101<br><br>102<br><br>103<br><br>104<br><br>105<br><br>106<br><br>107<br><br>108|`#include <iostream>`<br><br>`#include <queue>`<br><br>`#include <vector>`<br><br>`using` `namespace` `std;`<br><br>`char` `maze[5][5][5] = {`<br><br>    `{`<br><br>        `{``'*'``,``'*'``,``'*'``,``'*'``,``'*'``},`<br><br>        `{``'*'``,``'*'``,``'*'``,``'*'``,``'*'``},`<br><br>        `{``'*'``,``'*'``,``'*'``,``'*'``,``'.'``},`<br><br>        `{``'*'``,``'*'``,``'*'``,``'*'``,``'.'``},`<br><br>        `{``'*'``,``'*'``,``'s'``,``'.'``,``'.'``},`<br><br>    `},`                      <br><br>    `{`                       <br><br>        `{``'*'``,``'.'``,``'.'``,``'*'``,``'*'``},`<br><br>        `{``'*'``,``'*'``,``'*'``,``'*'``,``'.'``},`<br><br>        `{``'*'``,``'*'``,``'*'``,``'*'``,``'.'``},`<br><br>        `{``'*'``,``'*'``,``'*'``,``'*'``,``'*'``},`<br><br>        `{``'*'``,``'*'``,``'*'``,``'*'``,``'*'``},`<br><br>    `},`                      <br><br>    `{`                       <br><br>        `{``'*'``,``'.'``,``'.'``,``'*'``,``'*'``},`<br><br>        `{``'*'``,``'.'``,``'.'``,``'*'``,``'*'``},`<br><br>        `{``'.'``,``'.'``,``'#'``,``'*'``,``'.'``},`<br><br>        `{``'.'``,``'*'``,``'*'``,``'*'``,``'.'``},`<br><br>        `{``'.'``,``'*'``,``'*'``,``'*'``,``'.'``},`<br><br>    `},`                      <br><br>    `{`                       <br><br>        `{``'*'``,``'*'``,``'*'``,``'*'``,``'*'``},`<br><br>        `{``'*'``,``'*'``,``'*'``,``'*'``,``'*'``},`<br><br>        `{``'*'``,``'*'``,``'*'``,``'*'``,``'*'``},`<br><br>        `{``'*'``,``'*'``,``'*'``,``'*'``,``'*'``},`<br><br>        `{``'.'``,``'*'``,``'*'``,``'.'``,``'.'``},`<br><br>    `},`                      <br><br>    `{`                       <br><br>        `{``'*'``,``'*'``,``'*'``,``'*'``,``'*'``},`<br><br>        `{``'*'``,``'*'``,``'.'``,``'.'``,``'*'``},`<br><br>        `{``'*'``,``'.'``,``'.'``,``'.'``,``'*'``},`<br><br>        `{``'.'``,``'.'``,``'*'``,``'.'``,``'*'``},`<br><br>        `{``'.'``,``'*'``,``'*'``,``'.'``,``'*'``}`<br><br>    `}`<br><br>`};`<br><br>`struct` `Point {`<br><br>    `int` `layer, row, col;`<br><br>    `string path;`  `// 路径跟踪变量`<br><br>`};`<br><br>`bool` `isValid(``int` `layer,` `int` `row,` `int` `col) {`<br><br>    `// 检查点是否在地图内并且是可行走的`<br><br>    `return` `layer >= 0 && layer < 5 && row >= 0 && row < 5 && col >= 0 && col < 5 && maze[layer][row][col] !=` `'*'``;`<br><br>`}`<br><br>`void` `bfs() {`<br><br>    `queue<Point> q;`<br><br>    `q.push({ 0, 4, 2,` `""` `});`  `// 将起点放入队列中`<br><br>    `bool` `visited[5][5][5] = {` `false` `};`<br><br>    `visited[0][0][0] =` `true``;`  `// 该变量用于记录图中的每个节点是否已被访问过`<br><br>    `while` `(!q.empty()) {`<br><br>        `Point p = q.front();`<br><br>        `q.pop();`<br><br>        `int` `layer = p.layer;`<br><br>        `int` `row = p.row;`<br><br>        `int` `col = p.col;`<br><br>        `string path = p.path;`<br><br>        `// 判断是否到终点了`<br><br>        `if` `(maze[layer][row][col] ==` `'#'``) {`<br><br>            `cout << path << endl;`<br><br>            `return``;`<br><br>        `}`<br><br>        `// 检查每个方向，如果有效就排队`<br><br>        `if` `(isValid(layer, row - 1, col) && !visited[layer][row - 1][col]) {`<br><br>            `q.push({ layer, row - 1, col, path +` `'w'` `});`<br><br>            `visited[layer][row - 1][col] =` `true``;`<br><br>        `}`<br><br>        `if` `(isValid(layer, row + 1, col) && !visited[layer][row + 1][col]) {`<br><br>            `q.push({ layer, row + 1, col, path +` `'s'` `});`<br><br>            `visited[layer][row + 1][col] =` `true``;`<br><br>        `}`<br><br>        `if` `(isValid(layer, row, col - 1) && !visited[layer][row][col - 1]) {`<br><br>            `q.push({ layer, row, col - 1, path +` `'a'` `});`<br><br>            `visited[layer][row][col - 1] =` `true``;`<br><br>        `}`<br><br>        `if` `(isValid(layer, row, col + 1) && !visited[layer][row][col + 1]) {`<br><br>            `q.push({ layer, row, col + 1, path +` `'d'` `});`<br><br>            `visited[layer][row][col + 1] =` `true``;`<br><br>        `}`<br><br>        `if` `(isValid(layer - 1, row, col) && !visited[layer - 1][row][col]) {`<br><br>            `q.push({ layer - 1, row, col, path +` `'y'` `});`<br><br>            `visited[layer - 1][row][col] =` `true``;`<br><br>        `}`<br><br>        `if` `(isValid(layer + 1, row, col) && !visited[layer + 1][row][col]) {`<br><br>            `q.push({ layer + 1, row, col, path +` `'x'` `});`<br><br>            `visited[layer + 1][row][col] =` `true``;`<br><br>        `}`<br><br>    `}`<br><br>    `cout <<` `"No path found"` `<< endl;`<br><br>`}`<br><br>`int` `main() {`<br><br>    `bfs();`<br><br>    `return` `0;`<br><br>`}`|

### 实例五：2021巅峰极客 ****baby_maze****

- 题目附件
    
    [maze](https://bbs.kanxue.com/Maze%207632b5439dec4ff4930308a213f1ab61/maze.txt)
    

先尝试运行程序：

![图片描述](https://bbs.kanxue.com/upload/attach/202311/920613_NCNAXDQ77CB9GB9.webp)

根据题目输出，可以知道这个地图是正常的走东南西北四个方向，第一步是向南走。把程序丢入ida中。根据字符串地位到接收第一步向南字符“S”的函数：

![图片描述](https://bbs.kanxue.com/upload/attach/202311/920613_MMD996WPP4MXKRM.webp)

可以看到只有输入S字符才能进入下一步函数step_1，继续跟踪step_1函数：

![图片描述](https://bbs.kanxue.com/upload/attach/202311/920613_PCEXUFEBWPV8N8R.webp)

这个函数很简单，接收一个新的字符然后对其进行判断，输入‘A’，‘D’都会显示遇到了怪物，但是程序不会退出而是等待我们重新输入当前这个位置的方向字符，输入‘W’就退回到上一个函数，只有输入‘S’才能继续到下一个函数。到这里就发现有点不对劲了，和之前分析的几个程序不同，前面的程序判断完有几个方向之后就开始找地图字符串了，这个程序没得地图，它不是一次性接收所有路径然后进行判断，而是一次接收一个字符，用一个一个函数来对当前路径进行判断，而且继续往下跟踪会发现这个迷宫不只有一条路，在有些地方是有分叉路的。我这里尝试一个函数一个函数的走发现一个问题，根本走不完，函数太多了。所以这里我们不得不换一个思路了。

根据目前的发现可以提取到如下信息：

- 程序没有地图字符串。
- 走错方向并不会退出程序，而是停在当前位置等待重新输入。
- 在遇到分支路口时即使走错了也可以通过往反方向走回溯到分支路口
- 程序对每次输入都会有相应的信息输出，来表明是否走对了。

根据已有的信息，首先可以考虑使用pwntools实现程序交互，再使用BFS或者DFS来对地图进行遍历。大致思路为：

|   |   |
|---|---|
|1<br><br>2<br><br>3|`sh` `=` `process(``"./maze"``)`<br><br>`sh.recvuntil(``"This is the beginning. You can only go south.\n"``)`<br><br>`sh.send(b``'S'``)`|

先发送一个‘S’字符过去，然后利用sh接收程序的返回信息：

|   |   |
|---|---|
|1|`temp` `=` `sh.recvuntil(``'\n'``)`|

然后根据返回的信息，来判断是否走对了，

|   |   |
|---|---|
|1|`if` `temp` `=``=` `b``'OUCH!!!!\n'` `or` `temp` `=``=` `b``'I can\'t see the sky\n'` `or` `temp` `=``=` `b``'Shit!!\n'` `or` `temp` `=``=` `b``'Wall!!!\n'` `or` `temp` `=``=` `b``'Fxxk!!!\n'` `or` `temp` `=``=` `b``'nononononono\n'` `or` `temp` `=``=` `b``'Uh... yeah, no.\n'` `or` `temp` `=``=` `b``'Oh!!Monster\n'` `or` `temp` `=``=` `b``'Maybe this is a mistack\n'` `or` `temp` `=``=` `b``'Oh no!!!\n'` `or` `temp` `=``=` `b``'Let me out!!!\n'``:`|

这里依然要注意就是这里的判断需要循环判断直到找到正确的方向为止，然后就是并不是判断四个方向，来的那条路的反方向就不用管了。比如我是输入‘S’到的下一个函数，那就不用判断’W‘了，因为输入‘W’字符后程序依然会返回正确的字符串提示，这会让脚本无法区分，这里可以加上一个判断

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8|`opposite` `=` `{`<br><br>    `b``'W'``: b``'S'``,`<br><br>    `b``'A'``: b``'D'``,`<br><br>    `b``'D'``: b``'A'``,`<br><br>    `b``'S'``: b``'W'`<br><br>`}`<br><br>`if` `t!``=` `opposite[path``-``1``]]:`<br><br>            `payload` `+``=` `direct[i]`|

其中表示当前判断的方向。

做完这些前置操作后，然后我们需要判断是使用BFS算法还是DFS算法来对迷宫路径进行求解。

首先分析一下当前场景由于这是一个交互式的程序每次的步进都表示着与不同函数的交互，我们编写的脚本需要有一个东西能记录当前的路径走向，以便在走错路时回溯到分支路口。

对于特定的应用场景中，我们就需要更多的关注DFS和BFS针对撤销和回溯这两个操作的可行性。

1. **撤销操作**：在DFS中，当你沿着一个方向前进但最终碰到一个障碍时，你可以简单地从栈中弹出一个元素，然后尝试下一个方向。但在BFS中，你会探索所有可能的邻居，然后再探索这些邻居的邻居，所以你不能简单地“撤销”一个操作，因为你会丢失对其他邻居的引用。
2. **路径回溯**：在DFS中，当前的路径是通过栈来实时维护的，这使得回溯变得非常直观。在BFS中，尽管可以通过从目标点反向遍历父映射来重建路径，但这并不意味着可以轻松地“撤销”或“回溯”BFS中的单个操作。

简单点说就是由于DFS的递归和深入探索策略，它更容易实现撤销操作。当DFS探索一个不成功的路径时，它会自然地返回到上一个决策点，这与撤销操作的思想完美地契合。所以DFS算法更适合这个程序的路径寻找。

下面是一开始写的解决方案：

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>11<br><br>12<br><br>13<br><br>14<br><br>15<br><br>16<br><br>17<br><br>18<br><br>19<br><br>20<br><br>21<br><br>22<br><br>23<br><br>24<br><br>25<br><br>26<br><br>27<br><br>28<br><br>29<br><br>30<br><br>31<br><br>32<br><br>33<br><br>34<br><br>35<br><br>36<br><br>37<br><br>38<br><br>39<br><br>40<br><br>41<br><br>42<br><br>43<br><br>44<br><br>45<br><br>46<br><br>47<br><br>48<br><br>49|`from` `pwn` `import` `*`<br><br>`context(os``=``'linux'``, arch``=``'amd64'``, log_level``=``'info'``)`<br><br>`sh` `=` `process(``"./maze"``)`<br><br>`direct` `=` `[b``'W'``, b``'A'``, b``'S'``, b``'D'``]`<br><br>`opposite` `=` `{`<br><br>    `b``'W'``: b``'S'``,`<br><br>    `b``'A'``: b``'D'``,`<br><br>    `b``'D'``: b``'A'``,`<br><br>    `b``'S'``: b``'W'`<br><br>`}`<br><br>`success` `=` `[`<br><br>    `b``'Just do it\n'``,`<br><br>    `b``'GOGOGO\n'``,`<br><br>    `b``'Wuhu~!\n'``,`<br><br>    `b``'Wuhu\n'``,`<br><br>    `b``'You are so good\n'``,`<br><br>    `b``'Nice.\n'``,`<br><br>    `b``'Yeah~~\n'``,`<br><br>    `b``'Yeah~~~\n'``,`<br><br>    `b``'Let\'s go.\n'``,`<br><br>    `b``'Never stop\n'``,`<br><br>    `b``'So smart\n'``,`<br><br>`]`<br><br>`sh.recvuntil(b``"This is the beginning. You can only go south.\n"``)`<br><br>`sh.send(b``'S'``)`<br><br>`sh.recvuntil(b``'\n'``)`<br><br>`def` `dfs(path, depth):`<br><br>    `for` `i` `in` `direct:`<br><br>        `if` `i` `=``=` `opposite[path[``-``1``:]]:`<br><br>            `continue`<br><br>        `sh.send(i)`<br><br>        `feedback` `=` `sh.recvuntil(b``'\n'``)`<br><br>        `if` `feedback` `=``=` `b``"Good Job. \n"``:`<br><br>            `print``(``"I find it!!!"``)`<br><br>            `print``(path``+``i)`<br><br>            `return`<br><br>        `if` `feedback` `in` `success:`<br><br>            `print``(path``+``i)`<br><br>            `dfs(path` `+` `i, depth` `+` `1``)`<br><br>        `#`<br><br>        `sh.send(opposite[i])`  `# move back`<br><br>        `sh.recvuntil(b``'\n'``)`<br><br>`dfs(b``'S'``,``1``)`|

但是运行到一半报错了，这里使用的是递归算法，然后一层一层向下走：

![图片描述](https://bbs.kanxue.com/upload/attach/202311/920613_JPYNUC5R5KMBZ9E.webp)

查看了一下报错信息，发现是超过了python默认的最大递归层级，所以需要转变一下代码逻辑，我们可以创建一个文件来记录已经走出来的路径，然后循环打开迷宫程序，之前走过的路利用一个循环来直接输入到程序，然后继续寻找之后的路径，这样循环往复就可以避免递归超出递归层级的情况。

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>11<br><br>12<br><br>13<br><br>14<br><br>15<br><br>16<br><br>17<br><br>18<br><br>19<br><br>20<br><br>21<br><br>22<br><br>23<br><br>24<br><br>25<br><br>26<br><br>27<br><br>28<br><br>29<br><br>30<br><br>31<br><br>32<br><br>33<br><br>34<br><br>35<br><br>36<br><br>37<br><br>38<br><br>39<br><br>40<br><br>41<br><br>42<br><br>43<br><br>44|`from` `pwn` `import` `*`<br><br>`context(arch``=``'amd64'``,os``=``'linux'``,log_level``=``'info'``)`<br><br>`direc` `=` `[b``'W'``,b``'S'``,b``'A'``,b``'D'``]`<br><br>`anti_direc` `=` `[b``'S'``,b``'W'``,b``'D'``,b``'A'``]`<br><br>`payload` `=` `b``'SSSSSSSSSDDDDDDWWWWAAWWAAWWDDDDDDDDDDDDDDDDDDDDSSDDSSAASSSSAAAAWWAAWWWWAASSSSSSAASSDDSSSSDDWWWWDDSSDDDDWWDDDDDDWWAAAAWWDDDDWWAAWWWWDD'`<br><br>`def` `DFS(payload,length):`<br><br>    `if` `length` `=``=``480``:`<br><br>        `F` `=` `open``(``'pay.txt'``,``'a+'``)`<br><br>        `F.write(``str``(payload)` `+` `'\n'``)`<br><br>        `F.close()`<br><br>        `return` `0`<br><br>    `print``(payload)`<br><br>    `p` `=` `process(``'./maze'``)`<br><br>    `p.recvuntil(``'south.\n'``)`<br><br>    `p.sendline(payload)`<br><br>    `for` `i` `in` `range``(``0``,length``-``1``):`<br><br>        `p.recvuntil(``'\n'``)`<br><br>    `temp` `=` `p.recvuntil(``'\n'``)`<br><br>    `print``(temp)`<br><br>    `if` `temp` `=``=` `b``'OUCH!!!!\n'` `or` `temp` `=``=` `b``'I can\'t see the sky\n'` `or` `temp` `=``=` `b``'Shit!!\n'` `or` `temp` `=``=` `b``'Wall!!!\n'` `or` `temp` `=``=` `b``'Fxxk!!!\n'` `or` `temp` `=``=` `b``'nononononono\n'` `or` `temp` `=``=` `b``'Uh... yeah, no.\n'` `or` `temp` `=``=` `b``'Oh!!Monster\n'` `or` `temp` `=``=` `b``'Maybe this is a mistack\n'` `or` `temp` `=``=` `b``'Oh no!!!\n'` `or` `temp` `=``=` `b``'Let me out!!!\n'``:`<br><br>        `p.close()`<br><br>        `print``(``'WRRONG !!! -----'``,payload)`<br><br>        `return` `0`<br><br>    `if` `temp` `=``=` `b``'Good Job. \n'``:`<br><br>        `F``=``open``(``'map.txt'``,``'a'``)`<br><br>        `p.close()`<br><br>        `for` `i` `in` `range``(``100``):`<br><br>            `F.write(``str``(payload)` `+` `'\n'``)`<br><br>        `F.close()`<br><br>        `return` `0`<br><br>    `p.close()`<br><br>    `print``(``'------------------------------'``)`<br><br>    `t` `=` `payload[length``-``1``:length]`<br><br>    `for` `i` `in` `range``(``0``,``4``):`<br><br>        `if` `t!``=` `anti_direc[i]:`<br><br>            `payload` `+``=` `direc[i]`<br><br>            `DFS(payload,``len``(payload))`<br><br>            `payload` `=` `payload[``0``:``len``(payload)``-``1``]`<br><br>`DFS(payload,``len``(payload))`|

以上就是我个人关于迷宫题题型的一些收集，上面这个例子应该还有更好的解法，这个方法还是比较笨的，脚本跑下来也要不少时间。